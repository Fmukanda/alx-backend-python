pipeline {
    agent any
    
    environment {
        GIT_REPO = 'https://github.com/Fmukanda/alx-backend-python.git'
        BRANCH = 'main'
        PYTHON_VERSION = '3.9'  // This is for Jenkins agent, Docker uses 3.10
        
        // Docker configuration
        DOCKER_REGISTRY = 'docker.io'  // Change to your registry (Docker Hub, ECR, etc.)
        DOCKER_IMAGE_NAME = 'messaging_app'
        DOCKER_IMAGE_TAG = "${env.BUILD_NUMBER}-${env.GIT_COMMIT.substring(0,7)}"
        DOCKERFILE_PATH = './Dockerfile'
    }
    
    stages {
        stage('Checkout') {
            steps {
                script {
                    echo 'Cloning repository from GitHub...'
                    git branch: "${BRANCH}",
                        url: "${GIT_REPO}",
                        credentialsId: '480dc6a1-b85d-4f36-b38e-5bc3f8acbc0d'
                }
            }
        }
        
        stage('Validate Dockerfile') {
            steps {
                script {
                    echo 'Validating Dockerfile and dependencies...'
                    sh '''
                        # Check if Dockerfile exists
                        if [ ! -f Dockerfile ]; then
                            echo "ERROR: Dockerfile not found!"
                            exit 1
                        fi
                        
                        # Check if requirements.txt exists
                        if [ ! -f requirements.txt ]; then
                            echo "ERROR: requirements.txt not found!"
                            exit 1
                        fi
                        
                        # Check if manage.py exists (Django project)
                        if [ ! -f manage.py ]; then
                            echo "WARNING: manage.py not found - ensure this is a Django project or update CMD in Dockerfile"
                        fi
                        
                        echo "Dockerfile validation passed"
                        cat Dockerfile
                    '''
                }
            }
        }
        
        stage('Setup Environment') {
            steps {
                script {
                    echo 'Setting up Python environment for testing...'
                    sh '''
                        python -m venv venv
                        . venv/bin/activate
                        pip install --upgrade pip
                        
                        # Install system dependencies required for MySQL
                        sudo apt-get update || true
                        sudo apt-get install -y default-libmysqlclient-dev build-essential pkg-config || true
                    '''
                }
            }
        }
        
        stage('Install Dependencies') {
            steps {
                script {
                    echo 'Installing dependencies...'
                    sh '''
                        . venv/bin/activate
                        pip install -r requirements.txt
                        # Install pytest and reporting tools
                        pip install pytest pytest-html pytest-cov django-test-plus
                    '''
                }
            }
        }
        
        stage('Run Tests') {
            steps {
                script {
                    echo 'Running tests with pytest...'
                    sh '''
                        . venv/bin/activate
                        # Create test results directory
                        mkdir -p test-results
                        
                        # Run Django tests with pytest
                        pytest tests/ \
                            --html=test-results/report.html \
                            --junitxml=test-results/junit-report.xml \
                            --cov=.
                            --cov-report=html:test-results/coverage-html \
                            --cov-report=xml:test-results/coverage.xml \
                            -v
                        
                        # Also run Django's built-in test runner as backup
                        python manage.py test --noinput || echo "Django test runner completed"
                    '''
                }
            }
            post {
                always {
                    // Archive test results regardless of test outcome
                    junit 'test-results/junit-report.xml'
                    publishHTML([
                        allowMissing: false,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: 'test-results',
                        reportFiles: 'report.html',
                        reportName: 'Pytest HTML Report'
                    ])
                    publishHTML([
                        allowMissing: false,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: 'test-results/coverage-html',
                        reportFiles: 'index.html',
                        reportName: 'Coverage HTML Report'
                    ])
                }
            }
        }
        
        stage('Build Docker Image') {
            when {
                expression { 
                    currentBuild.result == null || currentBuild.result == 'SUCCESS' 
                }
            }
            steps {
                script {
                    echo 'Building Docker image with MySQL support...'
                    
                    // Validate Dockerfile content
                    sh '''
                        echo "Checking Dockerfile content..."
                        grep "FROM python:3.10-slim" Dockerfile || echo "WARNING: Dockerfile might not be using python:3.10-slim"
                        grep "mysql-client" Dockerfile || echo "WARNING: mysql-client might not be installed in Dockerfile"
                    '''
                    
                    // Build the Docker image with build args if needed
                    sh """
                        docker build \
                            -t ${DOCKER_REGISTRY}/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG} \
                            -f ${DOCKERFILE_PATH} \
                            .
                        
                        # Tag as latest
                        docker tag ${DOCKER_REGISTRY}/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG} ${DOCKER_REGISTRY}/${DOCKER_IMAGE_NAME}:latest
                    """
                    
                    echo "Docker image built: ${DOCKER_REGISTRY}/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}"
                    echo "Image size:"
                    sh "docker images | grep ${DOCKER_IMAGE_NAME}"
                }
            }
        }
        
        stage('Test Docker Image') {
            when {
                expression { 
                    currentBuild.result == null || currentBuild.result == 'SUCCESS' 
                }
            }
            steps {
                script {
                    echo 'Testing Docker image...'
                    
                    // Test that the image can be run and basic dependencies work
                    sh """
                        # Test that the image starts without errors
                        docker run --rm ${DOCKER_REGISTRY}/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG} python --version
                        
                        # Test Django management command
                        docker run --rm ${DOCKER_REGISTRY}/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG} python manage.py check --fail-level WARNING || echo "Django check completed"
                        
                        # Test that required Python packages are installed
                        docker run --rm ${DOCKER_REGISTRY}/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG} pip list | grep -i django || echo "Django package check"
                    """
                    
                    echo "Docker image test completed successfully"
                }
            }
        }
        
        stage('Security Scan') {
            when {
                expression { 
                    currentBuild.result == null || currentBuild.result == 'SUCCESS' 
                }
            }
            steps {
                script {
                    echo 'Running security scan on Docker image...'
                    // Using trivy for security scanning
                    sh """
                        docker run --rm \
                            -v /var/run/docker.sock:/var/run/docker.sock \
                            aquasec/trivy:latest image \
                            --severity HIGH,CRITICAL \
                            --exit-code 0 \
                            --format table \
                            ${DOCKER_REGISTRY}/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG} || true
                    """
                    
                    // Additional scan for configuration issues
                    sh """
                        docker run --rm \
                            -v /var/run/docker.sock:/var/run/docker.sock \
                            aquasec/trivy:latest config \
                            --exit-code 0 \
                            . || true
                    """
                }
            }
        }
        
        stage('Push Docker Image') {
            when {
                expression { 
                    (currentBuild.result == null || currentBuild.result == 'SUCCESS') &&
                    env.BRANCH_NAME == 'main'  // Only push from main branch, adjust as needed
                }
            }
            steps {
                script {
                    echo 'Pushing Docker image to registry...'
                    
                    // Login to Docker registry (configure credentials in Jenkins)
                    withCredentials([usernamePassword(
                        credentialsId: 'docker-registry-credentials',
                        usernameVariable: 'DOCKER_USERNAME',
                        passwordVariable: 'DOCKER_PASSWORD'
                    )]) {
                        sh """
                            docker login -u $DOCKER_USERNAME -p $DOCKER_PASSWORD ${DOCKER_REGISTRY}
                            docker push ${DOCKER_REGISTRY}/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}
                            docker push ${DOCKER_REGISTRY}/${DOCKER_IMAGE_NAME}:latest
                        """
                    }
                    
                    echo "Docker image pushed successfully: ${DOCKER_REGISTRY}/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}"
                    
                    // Store the image info for deployment
                    env.DEPLOYMENT_IMAGE = "${DOCKER_REGISTRY}/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}"
                }
            }
        }
        
        stage('Deploy to Staging') {
            when {
                expression { 
                    (currentBuild.result == null || currentBuild.result == 'SUCCESS') &&
                    env.BRANCH_NAME == 'main'
                }
            }
            steps {
                script {
                    echo 'Deploying to staging environment...'
                    
                    // Example deployment commands for different environments
                    sh """
                        echo "Deploying Django application with MySQL support"
                        echo "Image: ${env.DEPLOYMENT_IMAGE}"
                        echo "Port: 8000"
                        
                        # Example deployment commands (choose one based on your setup):
                        
                        # For Docker Compose:
                        # docker-compose -f docker-compose.staging.yml up -d
                        
                        # For Kubernetes:
                        # kubectl set image deployment/alx-backend-python alx-backend-python=${env.DEPLOYMENT_IMAGE} -n staging
                        
                        # For AWS ECS:
                        # aws ecs update-service --cluster staging-cluster --service alx-backend-python --force-new-deployment
                        
                        # Simple docker run for testing (remove in production):
                        # docker run -d -p 8000:8000 --name alx-backend-staging ${env.DEPLOYMENT_IMAGE}
                    """
                    
                    // Wait for application to be healthy
                    sh """
                        # Health check example
                        sleep 10
                        echo "Performing health check..."
                        curl -f http://localhost:8000/ || echo "Application health check"
                    """
                }
            }
        }
        
        stage('Run Migration Check') {
            when {
                expression { 
                    (currentBuild.result == null || currentBuild.result == 'SUCCESS') &&
                    env.BRANCH_NAME == 'main'
                }
            }
            steps {
                script {
                    echo 'Checking Django migrations...'
                    sh """
                        # Check for missing migrations
                        docker run --rm \
                            --network host \
                            ${env.DEPLOYMENT_IMAGE} \
                            python manage.py makemigrations --check --dry-run || echo "Migrations check completed"
                    """
                }
            }
        }
    }
    
    post {
        always {
            echo 'Pipeline completed - cleaning up...'
            script {
                // Stop and remove any test containers
                sh '''
                    docker stop alx-backend-staging || true
                    docker rm alx-backend-staging || true
                '''
                
                // Clean up Docker images to save disk space
                sh '''
                    docker system prune -f || true
                '''
                
                // Clean up workspace
                cleanWs()
            }
        }
        success {
            script {
                echo 'Pipeline succeeded! 🎉'
                def message = "Pipeline SUCCESS - ${env.JOB_NAME} [${env.BUILD_NUMBER}]\n"
                message += "Branch: ${env.BRANCH_NAME}\n"
                message += "Django Application: ${DOCKER_REGISTRY}/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}\n"
                message += "Port: 8000\n"
                message += "MySQL Client: Included in image\n"
                message += "Build URL: ${env.BUILD_URL}"
                
                emailext (
                    subject: "SUCCESS: Django App '${env.JOB_NAME} [${env.BUILD_NUMBER}]'",
                    body: message,
                    to: "fernandezmukanda@gmail.com"
                )
            }
        }
        failure {
            echo 'Pipeline failed! ❌'
            emailext (
                subject: "FAILED: Django App '${env.JOB_NAME} [${env.BUILD_NUMBER}]'",
                body: """
                The Django application pipeline failed.
                Project: alx-backend-python
                Branch: ${env.BRANCH_NAME}
                Check logs at: ${env.BUILD_URL}
                """,
                to: "fernandezmukanda@gmail.com"
            )
        }
    }
}
